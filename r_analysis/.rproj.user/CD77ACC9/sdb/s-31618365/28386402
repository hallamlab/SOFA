{
    "contents" : "# Aria Hahn March 27 2015\n\nimport sys\nimport argparse\nimport re\nfrom random import randint, seed\n\nclass FastaRecord():\n    def __init__(self, longname, sequence):\n      self.longname = longname\n      self.sequence = sequence\n      fields = [ x.strip() for x in self.longname.split(' ') ]\n      if len(fields) > 0:\n         self.name = fields[0]\n      else:\n         self.name = None\n\nclass FastaReader():\n    \"\"\"Parses a fasta record from a string or file.\"\"\"\n    stop = False\n    START_PATTERN = re.compile(r'^>')\n    name = None\n    future_name =None\n    sequence=\"\"\n    def __init__(self, fasta_filename):\n        try:\n            self.file = open(fasta_filename, 'r')\n        except IOError:\n            print \"Cannot open fasta file \" + fasta_filename\n\n    def __iter__(self):\n        return self\n\n    def next(self):\n        if self.stop:\n          raise StopIteration\n        \n        try:\n           if not self.name: \n               self.name = self.file.readline().strip()\n           line = self.file.readline()\n        except:\n           line = None\n\n        if not line:\n           self.stop = True\n           raise StopIteration\n\n        fragments = []\n        while line and not self.START_PATTERN.search(line):\n            fragments.append(line.strip()) \n            line = self.file.readline()\n\n       # print line\n        if self.future_name:\n            self.name = self.future_name\n\n        if line:\n            self.future_name = line.strip()\n        \n        self.sequence =''.join(fragments)\n        self.seqname = self.name\n        \n        return FastaRecord(self.name, self.sequence)\n\ndef get_parser():\n    parser = argparse.ArgumentParser(\n        description='simulates sequencing from a fasta file given your parameters - Note that there is no error model and sequences shorter then the length of an input sequence - (insert length + range)',\n        formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n\n    parser.add_argument('-i', '--input_sequence', help='The name of the input fasta file')\n    parser.add_argument('-o', '--output', help='The name of the output')\n    parser.add_argument('-n', '--pairnum', help='the number of read pairs from EACH input sequnce in the fasta file')\n    parser.add_argument('-l', '--readlen', help='the length of the reads') \n    parser.add_argument('-t', '--insertlen', help='the length of the pair reads - this can help you to determine if the reads overlap or not')\n    parser.add_argument('-r', '--range', help='reads will be readlenth + (0-range). Set to zero if youd like uniform read lengths')\n    return parser\n    \n\ndef main():\n    args = get_parser().parse_args()\n    #print args.input_sequence\n    \n    fasta_reader = FastaReader(args.input_sequence)\n    \n    if args.output:\n        fp = open(args.output, 'w')\n    \n    count = int(args.pairnum)\n    readl = int(args.readlen)\n    insert = int(args.insertlen)\n    rangeby = int(args.range) \n    list = {}\n    #print count\n    #print readl\n    # seed(12345) # first estimate\n    # seed(54321) # second estimate\n    seed(13232) # third estimate\n    \n    pair_counter = 0\n    \n    for record in fasta_reader:\n        name = record.longname[1:]\n        line = record.sequence\n        count = int(args.pairnum)\n        length=(len(line))#print length\n        \n        while count > 0:\n            if (length-(insert+rangeby)) > 0:\n                rand = randint(0,(length-(insert+rangeby)))\n                rand2 = randint(0,rangeby)\n                #print rand2    \n                rand3 = randint(0,rangeby)\n                #print rand3\n                # print str(rand + readl + rand2)\n                if rand not in list:\n                    fp.write(\">\" + name + \"##\" + str(pair_counter) + \"_\" + str(rand) + \":\" + str(rand + readl + rand2) + \"_1\" + \"\\n\")\n                    fp.write(line[(rand):(rand + readl + rand2)]+ \"\\n\")\n                    fp.write(\">\" + name + \"##\" + str(pair_counter) + \"_\" + str(rand + (insert -readl)) + \":\" + str(rand + (insert -readl) + readl + rand3 ) + \"_2\" + \"\\n\")\n                    fp.write(line[(rand + (insert-readl)):(rand + (insert -readl) + readl + rand3)] + \"\\n\")\n                    pair_counter += 1\n                    list[rand] = 1\n                    count = count - 1\n                # list = {}\n            else:\n                count = count -1\n        list = {}\n    # close the files\n    fp.close()\n\n\n\nif __name__ == '__main__':\n    main()\n",
    "created" : 1434930858514.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3146010870",
    "id" : "28386402",
    "lastKnownWriteTime" : 1427700276,
    "path" : "~/Desktop/SOFA/r_analysis2/data/SOFAMetaSimCOG.py",
    "project_path" : "data/SOFAMetaSimCOG.py",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "python"
}